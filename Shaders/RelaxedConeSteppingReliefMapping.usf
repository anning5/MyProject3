const int ConeSteps=15;
const int BinarySteps=8;

float3 p = float3(UV, 0);
float3 BiNormalLS = cross(NormalLS, TangentLS);
float3x3 tangentSpaceMatrix = float3x3(TangentLS, BiNormalLS, NormalLS);

//Run the relaxed cone stepping to find the new relief UV
float3 v = normalize(PosLS - CamPosLS);
v = mul(tangentSpaceMatrix, v);
v.z = abs(v.z);
v.xy *= DepthScale;

float3 p0 = p;

v /= v.z;

float dist = length(v.xy);

for(int i = 0; i < ConeSteps; i++)
{
    float4 tex = Texture2DSample(RelaxedConeReliefMap, RelaxedConeReliefMapSampler, p.xy);

    //The use of the saturate() function when calculating the distance to move guarantees that we stop on the first visited texel for which the viewing ray is under the relief surface.
    float height = saturate(tex.g - p.z);

    float coneRatio = tex.r;

    p += v * (coneRatio * height / (dist + coneRatio));
}

v *= p.z * 0.5;
p = p0 + v;

for(i = 0; i < BinarySteps; i++)
{
    float4 tex = Texture2DSample(RelaxedConeReliefMap, RelaxedConeReliefMapSampler, p.xy);
    v *= 0.5;
    if (p.z < tex.g)
        p += v;
    else
        p -= v;
}

float3 reliefIntersection = p;

float3 reliefColor = Texture2DSample(ReliefColorMap, ReliefColorMapSampler, reliefIntersection.xy).rgb;
float3 normal = Texture2DSample(ReliefBumpMap, ReliefBumpMapSampler, reliefIntersection.xy).rgb * 2 - 1;
normal.y = -normal.y;

//Run the relaxed cone stepping for the shadowing calculation
float3 directionLightTS = normalize(mul(tangentSpaceMatrix, DirectionalLightLS));
v = -directionLightTS;
v.z = abs(v.z);

p0 = p + p.z / v.z * -v;//Find the starting point from the light direction
p = p0;

v /= v.z;

dist = length(v.xy);

for(int i = 0; i < ConeSteps; i++)
{
    float4 tex = Texture2DSample(RelaxedConeReliefMap, RelaxedConeReliefMapSampler, p.xy);

    //The use of the saturate() function when calculating the distance to move guarantees that we stop on the first visited texel for which the viewing ray is under the relief surface.
    float height = saturate(tex.g - p.z);

    float coneRatio = tex.r;

    p += v * (coneRatio * height / (dist + coneRatio));
}

v *= p.z * 0.5;
p = p0 + v;

for(i = 0; i < BinarySteps; i++)
{
    float4 tex = Texture2DSample(RelaxedConeReliefMap, RelaxedConeReliefMapSampler, p.xy);
    v *= 0.5;
    if (p.z < tex.g)
        p += v;
    else
        p -= v;
}

bool lit = reliefIntersection.z < p.z;

return float4(reliefColor * saturate(dot(normal, directionLightTS.xyz)) * lit, 1);
return float4(reliefColor * lit, 1);
return float4(reliefColor * saturate(dot(normal, directionLightTS.xyz)), 1);
