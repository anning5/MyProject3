//A forward declaration of the external relaxed cone stepping function
void RelaxedConeStepping(float3 v, inout float3 p, const int ConeSteps, const int BinarySteps, Texture2D RelaxedConeReliefMap, SamplerState RelaxedConeReliefMapSampler);

const int ConeSteps=15;
const int BinarySteps=8;

float3 p = float3(UV, 0);
float3 BiNormalLS = cross(NormalLS, TangentLS);
float3x3 tangentSpaceMatrix = float3x3(TangentLS, BiNormalLS, NormalLS);

//Run the relaxed cone stepping to find the new relief UV
float3 v = normalize(PosLS - CamPosLS);
v = mul(tangentSpaceMatrix, v);
v.z = abs(v.z);
v.xy *= DepthScale;

RelaxedConeStepping(v, p, ConeSteps, BinarySteps, RelaxedConeReliefMap, RelaxedConeReliefMapSampler);

float3 reliefIntersection = p;

float3 reliefColor = Texture2DSample(ReliefColorMap, ReliefColorMapSampler, reliefIntersection.xy).rgb;
float3 normal = Texture2DSample(ReliefBumpMap, ReliefBumpMapSampler, reliefIntersection.xy).rgb * 2 - 1;
normal.y = -normal.y;

float3 diffuse = 0, cosTheta = 0, depthBias;

//Run the relaxed cone stepping for the directional light's shadowing calculation
float3 directionLightTS = normalize(mul(tangentSpaceMatrix, DirectionalLightLS));
//diffuse += saturate(dot(normal, directionLightTS.xyz));

v = -directionLightTS;
v.z = abs(v.z);

p += p.z / v.z * -v;//Find the starting point from the light direction

RelaxedConeStepping(v, p, ConeSteps, BinarySteps, RelaxedConeReliefMap, RelaxedConeReliefMapSampler);

//Below is an optimisation of saturate(dot(float3(0, 0, 1), directionLightTS.xyz))
cosTheta = saturate(directionLightTS.z);

depthBias = max(.04, tan(acos(cosTheta)) * 0.005);
float directionalLightShadow = lerp(1, 0.05, (reliefIntersection.z - depthBias) > p.z);

float shadow = 1;
//shadow = directionalLightShadow;

//Run the relaxed cone stepping for the point light's shadowing calculation
reliefIntersection.z = -reliefIntersection.z;//The intersection point has a negative z in the tangent space
float3 pointLightTS = PointLightPosTS - reliefIntersection;
reliefIntersection.z = -reliefIntersection.z;

float3 pointLightDistance = length(pointLightTS);
return float4(normal, 1);

v = -pointLightTS;
v.z = abs(v.z);
if(v.z > p.z)//If the point light is above the relief surface clamp it to the relief surface level which is at height 0
{
	p += p.z / v.z * -v;//Find the starting point from the light direction
}
else
{
	p += -v;
}

//p += p.z / v.z * -v;//Find the starting point from the light direction
//p -= v;//Find the starting point from the light direction

RelaxedConeStepping(v, p, ConeSteps, BinarySteps, RelaxedConeReliefMap, RelaxedConeReliefMapSampler);

pointLightTS = normalize(pointLightTS);
diffuse += saturate(dot(normal, pointLightTS)) / (pointLightDistance * pointLightDistance);

//Below is an optimisation of saturate(dot(float3(0, 0, 1), directionLightTS.xyz))
cosTheta = saturate(pointLightTS.z);

depthBias = max(.04, tan(acos(cosTheta)) * 0.005);
float pointLightShadow = lerp(1, 0.05, (reliefIntersection.z - depthBias) > p.z);
shadow = pointLightShadow;

return float4(reliefColor * diffuse, 1);
return float4(reliefColor * diffuse * shadow, 1);
return float4(diffuse, 1);

