void RelaxedConeStepping(float3 v, inout float3 p, const int ConeSteps, const int BinarySteps, Texture2D RelaxedConeReliefMap, SamplerState RelaxedConeReliefMapSampler);

const int ConeSteps=15;
const int BinarySteps=8;

float3 p = float3(UV, 0);
float3 BiNormalLS = cross(NormalLS, TangentLS);
float3x3 tangentSpaceMatrix = float3x3(TangentLS, BiNormalLS, NormalLS);

//Run the relaxed cone stepping to find the new relief UV
float3 v = normalize(PosLS - CamPosLS);
v = mul(tangentSpaceMatrix, v);
v.z = abs(v.z);
v.xy *= DepthScale;

RelaxedConeStepping(v, p, ConeSteps, BinarySteps, RelaxedConeReliefMap, RelaxedConeReliefMapSampler);

float3 reliefIntersection = p;

float3 reliefColor = Texture2DSample(ReliefColorMap, ReliefColorMapSampler, reliefIntersection.xy).rgb;
float3 normal = Texture2DSample(ReliefBumpMap, ReliefBumpMapSampler, reliefIntersection.xy).rgb * 2 - 1;
normal.y = -normal.y;

//Run the relaxed cone stepping for the shadowing calculation
float3 directionLightTS = normalize(mul(tangentSpaceMatrix, DirectionalLightLS));
v = -directionLightTS;
v.z = abs(v.z);

p += p.z / v.z * -v;//Find the starting point from the light direction

RelaxedConeStepping(v, p, ConeSteps, BinarySteps, RelaxedConeReliefMap, RelaxedConeReliefMapSampler);

//Below is an optimisation of saturate(dot(float3(0, 0, 1), directionLightTS.xyz))
float cosTheta = saturate(directionLightTS.z);

float bias = max(.04, tan(acos(cosTheta)) * 0.005);
float shadow = lerp(1, 0.05, (reliefIntersection.z - bias) > p.z);
float3 diffuse = reliefColor * saturate(dot(normal, directionLightTS.xyz));

return float4(diffuse * shadow, 1);
return float4(diffuse, 1);

