const int search_steps = 128;
float bestConeRatio = 1;

float2 halfTexelSize = TexelSize.xy * 0.5;
//return halfTexelSize.x;
//halfTexelSize = 0;
for(int i = (int)StartTexelIndex; i < (int)EndTexelIndex; i++)
{
	int rowIndex = i / (int)TexelSize.z;
	int colomnIndex = i % (int)TexelSize.z;
	float2 lookUpUV = float2(colomnIndex * TexelSize.x + halfTexelSize.x, rowIndex * TexelSize.y + halfTexelSize.y);

	float3 p = float3(UV, 0);

	float3 o = float3(lookUpUV, 0);
	o.z = Texture2DSample(ReliefMap, ReliefMapSampler, o.xy).w;

	float3 v = o - p;
	v /= v.z;
	v *= 1.0 - o.z;
	v /= search_steps;

	p = o;

	for(int j = 0; j < search_steps; j++)
	{
		float d = Texture2DSample(ReliefMap, ReliefMapSampler, p.xy).w;

		if (d <= p.z)
			p += v;
	}
	float d = Texture2DSample(ReliefMap, ReliefMapSampler, UV).w;

	float r = length(p.xy - UV);

	r = (p.z >= d) ? 1.0 : r / (d - p.z);		

	if (bestConeRatio > r)
	{
		bestConeRatio = r;
	}
}

float best_r = Texture2DSample(ConeSteppingMap, ConeSteppingMapSampler, UV).x;
if(bestConeRatio > best_r)
{
	bestConeRatio = best_r;
}

return bestConeRatio;
